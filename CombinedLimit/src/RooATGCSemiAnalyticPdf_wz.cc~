/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "RooAbsData.h"
#include "HiggsAnalysis/CombinedLimit/interface/RooATGCSemiAnalyticPdf_wz.h" 

#include <math.h> 
#include "TMath.h" 
#include "RooFormulaVar.h"
#include "RooRealVar.h"
#include "RooFit.h"

#include "TFile.h"

//using namespace RooFit ;

ClassImpUnique(RooATGCSemiAnalyticPdf_wz,MAGICWORDOFSOMESORT_wz) 

RooATGCSemiAnalyticPdf_wz::RooATGCSemiAnalyticPdf_wz() : 
  type_(notype), P_dk(0), P_dg1(0), P_dkdg1(0)
{
  initializeProfiles();
}

RooATGCSemiAnalyticPdf_wz::RooATGCSemiAnalyticPdf_wz(const char *name, 
						     const char *title, 
						     RooAbsReal& _x,
						     RooAbsReal& _dkg,
						     RooAbsReal& _lZ,
						     RooAbsReal& _dg1,
						     RooAbsReal& _SM_shape,
						     //					       RooAbsData& _SM_shape,
						     const char * parFilename,
						     const unsigned& lt) :
  RooAbsPdf(name,title),
   x("observable","observable",this,_x),
   lZ("lZ","lZ",this,_lZ),
   dkg("dkg","dkg",this,_dkg),
   dg1("dg1","dg1",this,_dg1),
   //   SM_shapePdf("SM_shapePdf","SM_shapePdf",this,_SM_shapePdf),
  SM_shape("SM_shape","SM_shape",this,_SM_shape),
  //  SM_shape("SM_shape","SM_shape",this,bins),
  //   SM_shape(_SM_shape),
   type_((LimitType)lt),
   profileFilename(parFilename),
   P_dk(0), P_dg1(0), P_dkdg1(0)
{ 
  initializeProfiles();
  initializeNormalization(std::string(""),_x,_SM_shape);
  const char* pwd = gDirectory->GetPath();
  TFile *f = TFile::Open(parFilename,"READ");  
  gDirectory->cd(pwd);

  std::vector<double> bins_;
  //  std::vector<double> bins;

  const RooRealVar& rdep = dynamic_cast<const RooRealVar&>(_x);
  int N_bins=rdep.getBinning("").numBins();

  cout << "RooATGCSemi place 4 N_bins "<< N_bins<< endl;

  for (int i=0;i<N_bins;i++){
    if (i==0){
      bins_.push_back(rdep.getBinning("").binLow(i));
      //      bins.push_back(rdep.getBinning("").binLow(i));
      cout << i<<" "<< rdep.getBinning("").binLow(i) <<endl;
    }
    bins_.push_back(rdep.getBinning("").binHigh(i));
    //    bins.push_back(rdep.getBinning("").binHigh(i));
    cout << i<<" "<< rdep.getBinning("").binHigh(i) <<endl;
  }

    cout << " semi place 92 "<< endl;
    readProfiles(bins_,*f);
    //    readProfiles(bins,*f); // radi
  f->Close();
} 

RooATGCSemiAnalyticPdf_wz::RooATGCSemiAnalyticPdf_wz(const RooATGCSemiAnalyticPdf_wz& other, 
					       const char* name) :  
  RooAbsPdf(other,name),
  x("observable",this,other.x),
  lZ("lZ",this,other.lZ),
  dkg("dkg",this,other.dkg),
  dg1("dg1",this,other.dg1),
  SM_shape("SM_shape",this,other.SM_shape),
  //  SM_shape(other.SM_shape),
  type_(other.type_),
  integral_basis(other.integral_basis),
  bins(other.bins),
  profileFilename(other.profileFilename),
  P_dk(0), P_dg1(0), P_dkdg1(0)
{ 
  initializeProfiles();
  cout << "\t\t\t testing: "<<profileFilename << endl;
  initializeBins(x.arg());
  const char* pwd = gDirectory->GetPath();
  TFile *f = TFile::Open(profileFilename,"READ");  
  gDirectory->cd(pwd);  
  cout << " semi place 93 "<< endl;
  //  std::string rName = ( rangeName == 0 ? std::string("") : std::string(rangeName) );
  //  cout << integral_basis[rName][1]<< endl;
  readProfiles(bins,*f); // ne radi
  f->Close();
} 

void RooATGCSemiAnalyticPdf_wz::initializeProfiles() {
  /*
  P_dk = new TProfile2D*[7]();
  P_dg1 = new TProfile2D*[7]();
  P_dkdg1 = new TProfile2D*[7]();
*/
int const N_bins=20;
  cout << "RooATGCSemi place 5 N_bins "<< N_bins<< endl;

  P_dk = new TH2D*[N_bins]();
  P_dg1 = new TH2D*[N_bins]();
  P_dkdg1 = new TH2D*[N_bins]();

}


void RooATGCSemiAnalyticPdf_wz::initializeBins(const RooAbsReal& dep) const {

  std::vector<double> bins;
  //  bins=std::vector<double>();
  const RooRealVar& rdep = dynamic_cast<const RooRealVar&>(dep);
  int N_bins=rdep.getBinning("").numBins();
  for(int i=0; i<N_bins; ++i) {
    cout <<i <<" initializeBins  rooATGCSemi... "<<rdep.getBinning("").binLow(i)<<" - "<< rdep.getBinning("").binHigh(i)  << endl;

    //    Double_t bin_low=rdep.getBinning("").binLow(i);
    //    Double_t bin_high=rdep.getBinning("").binHigh(i);
    if (i==0){
      //      bins_.push_back(rdep.getBinning("").binLow(i));
      bins.push_back(rdep.getBinning("").binLow(i));
      cout << i<<" "<< rdep.getBinning("").binLow(i) <<endl;
    }
    //    bins_.push_back(rdep.getBinning("").binHigh(i));
    bins.push_back(rdep.getBinning("").binHigh(i));
    cout << i<<" "<< rdep.getBinning("").binHigh(i) <<endl;

  }
}


void RooATGCSemiAnalyticPdf_wz::initializeNormalization(const std::string& rName,
						     const RooAbsReal& dep,
						     const RooAbsReal& shape) const {
  //						     const RooAbsData& shape) const {
  integral_basis[rName] = std::vector<double>();

  //  std::vector<double> bins;

  /*  
  //int const N_bins=15;
  //  for( int i = 0; i<N_bins; ++i ) {

  //    RooFormulaVar temp("temp","integral of x^i * shape",
  //	       Form("@1*@0**%i",i),RooArgList(dep,shape));
  RooFormulaVar temp("temp","integral of x^i * shape",
		     Form("@1*@0"),RooArgList(dep,shape));
    //		       Form("@0"),RooArgList(shape));
  RooRealVar rang("rang","rang",200,450);
  rang.setRange("sigRegion",400,450);

  //  RooAbsReal* integral = temp.createIntegral(RooArgSet(dep),RooArgSet(),rName.c_str());
  //  RooAbsReal* integral = temp.createIntegral(RooArgSet(dep),RooArgSet(),RooFit::Range("sigRegion"));
  RooAbsReal* integral = temp.createIntegral(RooArgSet(dep),RooArgSet(),RooFit::Range(200,300));
  */

  /*
int const N_bins=15;
int const bins_first=200.;
int const bins_last=800.;

double bin_width=(bins_last-bins_first)/N_bins;
  */

  const RooRealVar& rdep = dynamic_cast<const RooRealVar&>(dep);
  int N_bins=rdep.getBinning("").numBins();

  cout <<" RooATGCSemi 6 ... N_bins: "<< N_bins << endl;

//  cout <<"\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ reading prfiles..\n" << endl;
  int i;
  //  for(i=0; i<=6; ++i) {
    cout <<" \t\t filling bins "<< endl;
  for(i=0; i<N_bins; ++i) {

    cout <<" bin x "<< i << endl;
    /*
    Double_t bin_low=bins_first+(i*bin_width);
    Double_t bin_high=bins_first+(i+1)*bin_width;
    */

    cout <<i <<"  rooATGCSemi... "<<rdep.getBinning("").binLow(i)<<" - "<< rdep.getBinning("").binHigh(i)  << endl;

    Double_t bin_low=rdep.getBinning("").binLow(i);
    Double_t bin_high=rdep.getBinning("").binHigh(i);

    if (i==0){
      //      bins_.push_back(rdep.getBinning("").binLow(i));
      bins.push_back(rdep.getBinning("").binLow(i));
      cout << i<<" "<< rdep.getBinning("").binLow(i) <<endl;
    }
    //    bins_.push_back(rdep.getBinning("").binHigh(i));
    bins.push_back(rdep.getBinning("").binHigh(i));
    cout << i<<" "<< rdep.getBinning("").binHigh(i) <<endl;



    //    const char rangename="range";

    /*
    RooRealVar rang("rang","rang",200,300);
    rang.setRange("sigRegion",bin_low,bin_high);
    //    RooAbsReal* integral = shape.createIntegral(RooArgSet(dep),RooArgSet(),"sigRegion");
    RooAbsReal* integral = shape.createIntegral(RooArgSet(dep),RooArgSet(),"sigRegion");
    cout << "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@bin "<<i<<" content: "<<integral->getVal() << endl;
    integral_basis[rName].push_back(integral->getVal());
    */


    /*    
    const RooRealVar& rdep = dynamic_cast<const RooRealVar&>(dep);
    //    rdep.setRange(200., 300.);
    const char* range="signal";
    rdep.setRange(*(&range), 200., 300.);
    RooAbsReal* integral = shape.createIntegral(RooArgSet(dep),RooArgSet(),range);
    cout << "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@bin "<<i<<" content: "<<integral->getVal() << endl;
    integral_basis[rName].push_back(integral->getVal());
    */

    //    RooRealVar& rdep = dynamic_cast<RooRealVar&>(dep);

    /*
    const int a = 3;
    int& b = const_cast<int&>(a);
    */
    RooRealVar& b = const_cast<RooRealVar&>(rdep);



    const string intRange="integRange";

    /*
    const double& min=200.;
    const double& max=300.;
    */

    //    rdep.setRange((const char*)intRange.c_str(),(Double_t)(250.),(Double_t)(300.));
    //    b.setRange((const char*)intRange.c_str(),(Double_t)(250.),(Double_t)(300.)); //ok
    b.setRange((const char*)intRange.c_str(),bin_low,bin_high); //ok
    //    rdep.setRange((const char*)intRange.c_str(),min,max);
    RooAbsReal* integral = shape.createIntegral(RooArgSet(rdep),RooArgSet(),(const char*)intRange.c_str());

    //const std::string& rName
    //  RooAbsReal* integral = temp.createIntegral(RooArgSet(dep),RooArgSet(),rName.c_str());

    //const string& outfIn
    //(char*)outfIn.c_str()

    //    cout <<"bin "<< bin_low<<"-"<<bin_high<<"  integral: "<<integral->getVal()/(bin_high-bin_low)  << endl;
    cout <<"bin "<< bin_low<<"-"<<bin_high<<"  integral: "<<integral->getVal()  << endl;
    //    cout <<"bin "<< bin_low<<"-"<<bin_high<<"  integral: "<<integral->getVal()/(bin_high-bin_low)  << endl;
    integral_basis[rName].push_back(integral->getVal());
    //integral_basis[rName].push_back(integral->getVal()/(bin_high-bin_low));

    delete integral;
  }

  /*
 RooRealVar y("y","y",-10,10) ;
 y.setRange("signal",-3,3) ;
 RooAbsReal* igxy_sig = gxy.createIntegral(RooArgSet(x,y),NormSet(RooArgSet(x,y)),Range("signal")) ;
  */
  
  /*
    set = (RooArgSet*)d0->get(i); //Getting xi value 
    xi = (RooRealVar*)set->find(xi->GetName());//This line seems a bit redundant (as it seems to work without it)
    xi->setRange("xirange",0.1,0.9);
   
  */

  //  x.setRange("signal",-5,5);
  //  gxy.createIntegral(RooArgSet(x,y),RooFit.NormSet(RooArgSet(x,y)),RooFit.Range("signal"));

  /*
  //  RooDataSet* dh ;
  for(Int_t i=0 ; i<shape.numEntries() ; i++) {
    //    shape.get(i) ;
    cout <<"bin "<<i <<" content: "<< shape.weight(i) << endl ;
    integral_basis[rName].push_back(shape.weight());
  }
*/

  //  }
}

void RooATGCSemiAnalyticPdf_wz::readProfiles(std::vector<double> bins,TDirectory& dir) const {

  int N_bins=bins.size()-1;
  cout << "RooATGCSemi place 7 N_bins "<< N_bins<< endl;
  /*
int const N_bins=15;
int const bins_first=200.;
int const bins_last=800.;

double bin_width=(bins_last-bins_first)/N_bins;
  */
//  cout <<"\n@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ reading prfiles..\n" << endl;
  int i;
  //  for(i=0; i<=6; ++i) {
  for(i=0; i<N_bins; ++i) {
    cout <<"bins: "<<bins[i]<<" - "<< bins[i+1]  << endl;
    //    int bin_low=bins[i];
    //    int bin_high=bins[i+1];
    /*
    int bin_low=bins_first+(i*bin_width);
    int bin_high=bins_first+(i+1)*bin_width;
    */
    if (P_dk[i]) delete P_dk[i];
    //    TString dkname = TString::Format("p%i_lambda_dkg", i);
    //    TString dkname = TString::Format('bin_content_lam_dk_%i_%ito%iGeV',%(i,bin_low,bin_high));
    //    TString dkname = TString::Format("bin_content_lam_dk_%i_%ito%iGeV",i+1,bin_low,bin_high);
    TString dkname = TString::Format("bin_content_lam_dk_%i",i+1);
    //    dir.ls();
    cout <<"  .. i am looking for: " <<dkname<< endl;
    P_dk[i] = dynamic_cast<TH2D *>(dir.Get(dkname)->Clone(dkname+"new"));
    P_dk[i]->SetDirectory(0);
    if (P_dg1[i]) delete P_dg1[i];
    //   TString dg1name = TString::Format("p%i_lambda_dg1", i);
    //    TString dg1name = TString::Format("bin_content_lam_dg_%i_%ito%iGeV",i+1,bin_low,bin_high);
    TString dg1name = TString::Format("bin_content_lam_dg_%i",i+1);
    P_dg1[i] = dynamic_cast<TH2D *>(dir.Get(dg1name)->Clone(dg1name+"new"));
    P_dg1[i]->SetDirectory(0);
    //    TString dkdg1name = TString::Format("p%i_dkg_dg1", i);
    //    TString dkdg1name = TString::Format("bin_content_dk_dg_%i_%ito%iGeV",i+1,bin_low,bin_high);
    TString dkdg1name = TString::Format("bin_content_dk_dg_%i",i+1);
    P_dkdg1[i] = dynamic_cast<TH2D *>(dir.Get(dkdg1name)->Clone(dkdg1name+"new"));
    P_dkdg1[i]->SetDirectory(0);
  }

}

void RooATGCSemiAnalyticPdf_wz::readProfiles(RooATGCSemiAnalyticPdf_wz const& other) {

  int N_bins=other.bins.size()-1;

  cout << "RooATGCSemi place 8 N_bins "<< N_bins<< endl;

  /*
int const N_bins=15;
int const bins_first=200.;
int const bins_last=800.;

double bin_width=(bins_last-bins_first)/N_bins;
  */
  for (int i = 0; i<N_bins; ++i) {
    //    int bin_low=bins[i];
    //    int bin_high=bins[i+1];
    /*
    int bin_low=bins_first+(i*bin_width);
    int bin_high=bins_first+(i+1)*bin_width;
    */
    //    TString dkname = TString::Format("p%i_lambda_dkg", i);
    //    TString dkname = TString::Format("bin_content_lam_dk_%i_%ito%iGeV",i+1,bin_low,bin_high);
    TString dkname = TString::Format("bin_content_lam_dk_%i",i+1);
    P_dk[i] = dynamic_cast<TH2D *>(other.P_dk[i]->Clone(dkname+"new"));
    P_dk[i]->SetDirectory(0);
    //    TString dg1name = TString::Format("bin_content_lam_dg_%i_%ito%iGeV",i,bin_low,bin_high);
    TString dg1name = TString::Format("p%i_lambda_dg1", i);
    P_dg1[i] = dynamic_cast<TH2D *>(other.P_dg1[i]->Clone(dg1name+"new"));
    P_dg1[i]->SetDirectory(0);
    //    TString dkdg1name = TString::Format("p%i_dkg_dg1", i);
    //    TString dkdg1name = TString::Format("bin_content_dk_dg_%i_%ito%iGeV",i+1,bin_low,bin_high);
    TString dkdg1name = TString::Format("bin_content_dk_dg_%i",i+1);
    P_dkdg1[i] = dynamic_cast<TH2D *>(other.P_dkdg1[i]->Clone(dkdg1name+"new"));
    P_dkdg1[i]->SetDirectory(0);
  }
}

RooATGCSemiAnalyticPdf_wz::~RooATGCSemiAnalyticPdf_wz() {
int const N_bins=20;
  cout << "RooATGCSemi place 9 N_bins "<< N_bins<< endl;

  for(int i = 0; i<N_bins; ++i) {
    if (P_dk[i])
      delete P_dk[i];
    if (P_dg1[i])
      delete P_dg1[i];
    if (P_dkdg1[i])
      delete P_dkdg1[i];
  }
  delete[] P_dk;
  delete[] P_dg1;
  delete[] P_dkdg1;
}

Double_t RooATGCSemiAnalyticPdf_wz::evaluate() const 
{ 

  cout <<"evaluate..." << endl;
  // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 

  TH2D ** P = NULL;
  double v1(0.0), v2(0.0);
  switch(type_) {
  case dkglZ:
    P = P_dk;
    v1 = lZ;
    v2 = dkg;
    break;
  case dg1lZ:
    P = P_dg1;
    v1 = lZ;
    v2 = dg1;
    break;
  case dkdg1:
    P = P_dkdg1;
    v1 = dkg;
    v2 = dg1;
    break;
  case notype:
    assert(NULL && "invalid limit type!");
    break;
  }
  
  if (not P[0]) {
    TFile f(profileFilename);
    cout << " semi place 90 "<< endl;
    readProfiles(bins,f); // ne radi
    f.Close();
  }

  if (v1 < P[0]->GetXaxis()->GetXmin())
    v1 = P[0]->GetXaxis()->GetXmin();
  if (v1 > P[0]->GetXaxis()->GetXmax())
    v1 = P[0]->GetXaxis()->GetXmax();
  if (v2 < P[0]->GetYaxis()->GetXmin())
    v2 = P[0]->GetYaxis()->GetXmin();
  if (v2 > P[0]->GetYaxis()->GetXmax())
    v2 = P[0]->GetYaxis()->GetXmax();
 
  double ret(0.);
  /*
  for(int i = 0; i<N_bins; i++) {
    // std::cout << P_dk[i]->GetName() << '\n';
    ret += P[i]->Interpolate(v1, v2)*TMath::Power(x, i)*SM_shape;
  }
  */

  /*
  for(int i = 0; i< 15; i++) {
    // std::cout << P_dk[i]->GetName() << '\n';
    ret += P[i]->Interpolate(v1, v2)*SM_shape;
    cout <<"  -> pdf evaluate(): v1 "<< v1<<" v2 "<<v2<<" P["<<i<<"]="<< P[i]->Interpolate(v1, v2)<<" SM_Shape "<< SM_shape<<" -> ret= "<<ret<< endl;
  }
  */

  /*    
  int const N_bins=15;
  int const bins_first=200.;
  int const bins_last=800.;
  double bin_width=(bins_last-bins_first)/N_bins;
  int bin_with_x=int((x-bins_first)/bin_width)+1;
  */

  int N_bins=bins.size()-1;
  cout << "RooATGCSemi place 10 N_bins "<< N_bins<< endl;

    int bin_with_x=1;
    for (int j=0;j<N_bins;j++)
      if (x<bins[j+1] && x>bins[j]) bin_with_x=j+1;


  ret = P[bin_with_x-1]->Interpolate(v1, v2)*SM_shape;

  cout <<"  ---> pdf evaluate(): ret: "<< ret<< endl;
  cout <<"  -> pdf evaluate(): Pt "<<x <<" v1 "<< v1<<" v2 "<<v2<<" P["<<bin_with_x-1<<"]="<< P[bin_with_x-1]->Interpolate(v1, v2)<<" SM_Shape "<< SM_shape<<" -> ret= "<<ret<< endl;
  
  if (ret < 0.) ret = 0.;
  return ret; 
}

Int_t RooATGCSemiAnalyticPdf_wz::
getAnalyticalIntegral(RooArgSet& allVars,RooArgSet& analVars, 
		      const char* /*rangeName*/) const {  
  if (matchArgs(allVars,analVars,x)) return 1 ;
  return 0 ;
}

Double_t RooATGCSemiAnalyticPdf_wz::
analyticalIntegral(Int_t code, const char* rangeName) const {  

  assert(code==1 && "invalid analytic integration code!");

  std::string rName = ( rangeName == 0 ? std::string("") : std::string(rangeName) );
  if( integral_basis.find(rName) == integral_basis.end() ) {
    initializeNormalization(rName,x.arg(),SM_shape.arg());
  }

  TH2D ** P = NULL;
  double v1(0.0), v2(0.0);
  switch(type_) {
  case dkglZ:
    P = P_dk;
    v1 = lZ;
    v2 = dkg;
    break;
  case dg1lZ:
    P = P_dg1;
    v1 = lZ;
    v2 = dg1;
    break;
  case dkdg1:
    P = P_dkdg1;
    v1 = dkg;
    v2 = dg1;
    break;
  default:
    assert(code==1 && "invalid limit type!");
    break;
  }

  if (not P[0]) {
    TFile f(profileFilename);
    cout << " semi place 91 "<< endl;
    readProfiles(bins,f);
    f.Close();
  }

  if (v1 < P[0]->GetXaxis()->GetXmin())
    v1 = P[0]->GetXaxis()->GetXmin();
  if (v1 > P[0]->GetXaxis()->GetXmax())
    v1 = P[0]->GetXaxis()->GetXmax();
  if (v2 < P[0]->GetYaxis()->GetXmin())
    v2 = P[0]->GetYaxis()->GetXmin();
  if (v2 > P[0]->GetYaxis()->GetXmax())
    v2 = P[0]->GetYaxis()->GetXmax();

  double ret(0.);
  /*
  for(int i = 0; i<= 6; ++i) {
    ret += P[i]->Interpolate(v1,v2)*integral_basis[rName][i];
  }
  */

  int N_bins=bins.size()-1;
  cout <<"  do integral placeX "<<N_bins << endl;
  //  for(Int_t i=0 ; i<15 ; i++) {
  for(Int_t i=0 ; i<N_bins ; i++) {
    ret += P[i]->Interpolate(v1, v2)*integral_basis[rName][i]
      //      *(bins[i+1]-bins[i])
      ;
    cout << i <<" + "<< P[i]->Interpolate(v1, v2)<<" * "<<integral_basis[rName][i]
      //	 <<" * "<< (bins[i+1]-bins[i])
	 <<" = "<<P[i]->Interpolate(v1, v2)*integral_basis[rName][i]
      // *(bins[i+1]-bins[i])  
	 <<" -> "<<ret << endl;
  }
  cout << "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@--> lZ: "<<v1<<" dk: "<<v2 <<" ret: "<<ret<< endl;
  
  cout << "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@---> integral: "<<ret<< endl;

  return ret;
}
