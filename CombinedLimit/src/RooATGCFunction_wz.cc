/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "HiggsAnalysis/CombinedLimit/interface/RooATGCFunction_wz.h" 

#include <math.h> 
#include "TMath.h" 

#include "TFile.h"

#include "RooFormulaVar.h"
#include "RooRealVar.h"
#include "RooFit.h"



ClassImpUnique(RooATGCFunction_wz,MAGICWORDOFSOMESORT_wz) 

RooATGCFunction_wz::RooATGCFunction_wz() : 
  P_dk(0), P_dg1(0)
{
  initializeProfiles();
}

RooATGCFunction_wz::RooATGCFunction_wz(const char *name, const char *title, 
                                 RooAbsReal& _x,
                                 RooAbsReal& _lZ,
                                 RooAbsReal& _dkg,
                                 RooAbsReal& _dg1,
                                 const char * parFilename) :
   RooAbsReal(name,title), 
   x("x","x",this,_x),
   lZ("lZ","lZ",this,_lZ),
   dkg("dkg","dkg",this,_dkg),
   dg1("dg1","dg1",this,_dg1),
   profileFilename(parFilename),
   P_dk(0), P_dg1(0)
{ 
  initializeProfiles();
  initializeBins(_x);
  const char* pwd = gDirectory->GetPath();
  TFile *f = TFile::Open(parFilename,"READ");  
  gDirectory->cd(pwd);
  std::cout << "@@@@@@@@ opened the input file!" << std::endl;
  std::vector<double> bins_;

  
  const RooRealVar& rdep = dynamic_cast<const RooRealVar&>(_x);
  int N_bins=rdep.getBinning("").numBins();
  

  for (int i=0;i<N_bins;i++){
    if (i==0){
      bins_.push_back(rdep.getBinning("").binLow(i));
    }
    bins_.push_back(rdep.getBinning("").binHigh(i));
  }

  readProfiles(bins_,*f);
  //  std::cout << "read profiles!" << std::endl;
  f->Close();
} 

RooATGCFunction_wz::RooATGCFunction_wz(const RooATGCFunction_wz& other, 
                                 const char* name) :  
  RooAbsReal(other,name), 
  lZ("lZ",this,other.lZ),
  dkg("dkg",this,other.dkg),
  dg1("dg1",this,other.dg1),
  bins(other.bins),
  profileFilename(other.profileFilename),
  P_dk(0), P_dg1(0)
{ 
  initializeProfiles();

  initializeProfiles();
  const char* pwd = gDirectory->GetPath();
  TFile *f = TFile::Open(profileFilename,"READ");  
  gDirectory->cd(pwd);  
  readProfiles(bins,*f);
  f->Close();
} 

void RooATGCFunction_wz::initializeProfiles() {
  int const N_bins=20;
  P_dk = new TH2D*[N_bins]();
  P_dg1 = new TH2D*[N_bins]();
}

void RooATGCFunction_wz::initializeBins(const RooAbsReal& dep){
  const RooRealVar& rdep = dynamic_cast<const RooRealVar&>(dep);
  bool bin_true=rdep.hasBinning("");
  if (!bin_true)
    cout <<"\t @@@@@@@@@@@ can't find biining! (RooATGCProcessScaling file)" << endl;
  int N_bins=rdep.getBinning("").numBins();
  for(int i=0; i<N_bins; ++i) {
    int bin_low=rdep.getBinning("").binLow(i);
    int bin_high=rdep.getBinning("").binHigh(i);   
    if (i==0){
      bins.push_back(bin_low);
    }
      bins.push_back(bin_high);
  }
}


void RooATGCFunction_wz::readProfiles(std::vector<double> bins, TDirectory& dir) const {

  int const N_bins=bins.size()-1;
   
  int i;
  for(i=0; i<N_bins; ++i) {

    if (P_dk[i]) delete P_dk[i];
    TString dkname = TString::Format("bin_content_lam_dk_%i",i+1);
    //    cout <<"trying to get: "<<dkname << endl;
    P_dk[i] = dynamic_cast<TH2D *>(dir.Get(dkname)->Clone(dkname+"new"));
    P_dk[i]->SetDirectory(0);
    if (P_dg1[i]) delete P_dg1[i];
    TString dg1name = TString::Format("bin_content_lam_dg_%i",i+1);
    P_dg1[i] = dynamic_cast<TH2D *>(dir.Get(dg1name)->Clone(dg1name+"new"));
    P_dg1[i]->SetDirectory(0);
  }
}

void RooATGCFunction_wz::readProfiles(RooATGCFunction_wz const& other) {

  int N_bins=other.bins.size()-1;
  for (int i = 0; i<N_bins; ++i) {
    TString dkname = TString::Format("bin_content_lam_dk_%i",i+1);
    //    cout <<"trying to get object: "<<dkname << endl;
    P_dk[i] = dynamic_cast<TH2D *>(other.P_dk[i]->Clone(dkname+"new"));
    P_dk[i]->SetDirectory(0);
    TString dg1name = TString::Format("bin_content_lam_dg_%i",i+1);
    P_dg1[i] = dynamic_cast<TH2D *>(other.P_dg1[i]->Clone(dg1name+"new"));
    P_dg1[i]->SetDirectory(0);
  }
}

RooATGCFunction_wz::~RooATGCFunction_wz() {
  int const N_bins=20;
  for(int i = 0; i<N_bins; ++i) {
    if (P_dk[i])
      delete P_dk[i];
    if (P_dg1[i])
      delete P_dg1[i];
  }
  delete[] P_dk;
  delete[] P_dg1;
}

Double_t RooATGCFunction_wz::evaluate() const 
{ 
  // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 

  TH2D ** P = P_dg1;
  double v1(lZ), v2(dg1);
  if(TMath::Abs(dg1)<0.000001) {
    P = P_dk;
    v2 = dkg;
  }

  if (not P[0]) {
    TFile f(profileFilename);
    readProfiles(bins,f);
    f.Close();
  }

  if (v1 < P[0]->GetXaxis()->GetXmin())
    v1 = P[0]->GetXaxis()->GetXmin();
  if (v1 > P[0]->GetXaxis()->GetXmax())
    v1 = P[0]->GetXaxis()->GetXmax();
  if (v2 < P[0]->GetYaxis()->GetXmin())
    v2 = P[0]->GetYaxis()->GetXmin();
  if (v2 > P[0]->GetYaxis()->GetXmax())
    v2 = P[0]->GetYaxis()->GetXmax();
 
  double ret(0.);

  int N_bins=bins.size()-1;

  for (int i = 0; i<N_bins; ++i) { 
    int bin_with_x=1;
    for (int j=0;j<N_bins;j++)
      if (x<bins[j+1] && x>bins[j]) bin_with_x=j+1;
    ret += P[bin_with_x-1]->Interpolate(v1, v2);
    //    cout <<" ------------> ATGCFunction: x= "<<x<<" bin= "<< bin_with_x<<" ret= "<<ret << endl;
  }
  //    cout <<"    ------------> ATGCFunction: ret= "<<ret << endl;

  if (ret < 0.) ret = 0.;
  return ret; 
}
