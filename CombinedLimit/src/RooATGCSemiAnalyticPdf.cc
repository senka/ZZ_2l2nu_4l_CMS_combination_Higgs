/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "HiggsAnalysis/CombinedLimit/interface/RooATGCSemiAnalyticPdf.h" 

#include <math.h> 
#include "TMath.h" 
#include "RooFormulaVar.h"

#include "TFile.h"

ClassImpUnique(RooATGCSemiAnalyticPdf,MAGICWORDOFSOMESORT) 

RooATGCSemiAnalyticPdf::RooATGCSemiAnalyticPdf() : 
  type_(notype), P_dk(0), P_dg1(0), P_dkdg1(0)
{
  initializeProfiles();
}

RooATGCSemiAnalyticPdf::RooATGCSemiAnalyticPdf(const char *name, 
					       const char *title, 
					       RooAbsReal& _x,
					       RooAbsReal& _dkg,
					       RooAbsReal& _lZ,
					       RooAbsReal& _dg1,
					       RooAbsReal& _SM_shape,
					       const char * parFilename,
					       const unsigned& lt) :
   RooAbsPdf(name,title),
   x("observable","observable",this,_x),
   lZ("lZ","lZ",this,_lZ),
   dkg("dkg","dkg",this,_dkg),
   dg1("dg1","dg1",this,_dg1),
   SM_shape("SM_shape","SM_shape",this,_SM_shape),
   type_((LimitType)lt),
   profileFilename(parFilename),
   P_dk(0), P_dg1(0), P_dkdg1(0)
{ 
  initializeProfiles();
  initializeNormalization(std::string(""),_x,_SM_shape);
  const char* pwd = gDirectory->GetPath();
  TFile *f = TFile::Open(parFilename,"READ");  
  gDirectory->cd(pwd);
  readProfiles(*f);
  f->Close();
} 

RooATGCSemiAnalyticPdf::RooATGCSemiAnalyticPdf(const RooATGCSemiAnalyticPdf& other, 
					       const char* name) :  
  RooAbsPdf(other,name),
  x("observable",this,other.x),
  lZ("lZ",this,other.lZ),
  dkg("dkg",this,other.dkg),
  dg1("dg1",this,other.dg1),
  SM_shape("SM_shape",this,other.SM_shape),
  type_(other.type_),
  integral_basis(other.integral_basis),
  profileFilename(other.profileFilename),
  P_dk(0), P_dg1(0), P_dkdg1(0)
{ 
  initializeProfiles();
  const char* pwd = gDirectory->GetPath();
  TFile *f = TFile::Open(profileFilename,"READ");  
  gDirectory->cd(pwd);  
  readProfiles(*f);
  f->Close();
} 

void RooATGCSemiAnalyticPdf::initializeProfiles() {
  P_dk = new TProfile2D*[7]();
  P_dg1 = new TProfile2D*[7]();
  P_dkdg1 = new TProfile2D*[7]();
}

void RooATGCSemiAnalyticPdf::initializeNormalization(const std::string& rName,
						     const RooAbsReal& dep,
						     const RooAbsReal& shape) const {
  integral_basis[rName] = std::vector<double>();
  for( int i = 0; i<=6; ++i ) {
    RooFormulaVar temp("temp","integral of x^i * shape",
		       Form("@1*@0**%i",i),RooArgList(dep,shape));
    RooAbsReal* integral = temp.createIntegral(RooArgSet(dep),RooArgSet(),rName.c_str());
    integral_basis[rName].push_back(integral->getVal());
    delete integral;
  }
}

void RooATGCSemiAnalyticPdf::readProfiles(TDirectory& dir) const {

  int i;
  for(i=0; i<=6; ++i) {
    
    if (P_dk[i]) delete P_dk[i];
    TString dkname = TString::Format("p%i_lambda_dkg", i);
    P_dk[i] = dynamic_cast<TProfile2D *>(dir.Get(dkname)->Clone(dkname+"new"));
    P_dk[i]->SetDirectory(0);
    if (P_dg1[i]) delete P_dg1[i];
    TString dg1name = TString::Format("p%i_lambda_dg1", i);
    P_dg1[i] = dynamic_cast<TProfile2D *>(dir.Get(dg1name)->Clone(dg1name+"new"));
    P_dg1[i]->SetDirectory(0);
    TString dkdg1name = TString::Format("p%i_dkg_dg1", i);
    P_dkdg1[i] = dynamic_cast<TProfile2D *>(dir.Get(dkdg1name)->Clone(dkdg1name+"new"));
    P_dkdg1[i]->SetDirectory(0);
  }

  // for (i=0; i<=6; i++) {
  //   std::cout << 'P' << i << "_dk " << P_dk[i]->GetName() << '\n';
  // }
}

void RooATGCSemiAnalyticPdf::readProfiles(RooATGCSemiAnalyticPdf const& other) {

  for (int i = 0; i<=6; ++i) {
    TString dkname = TString::Format("p%i_lambda_dkg", i);
    P_dk[i] = dynamic_cast<TProfile2D *>(other.P_dk[i]->Clone(dkname+"new"));
    P_dk[i]->SetDirectory(0);
    TString dg1name = TString::Format("p%i_lambda_dg1", i);
    P_dg1[i] = dynamic_cast<TProfile2D *>(other.P_dg1[i]->Clone(dg1name+"new"));
    P_dg1[i]->SetDirectory(0);
    TString dkdg1name = TString::Format("p%i_dkg_dg1", i);
    P_dkdg1[i] = dynamic_cast<TProfile2D *>(other.P_dkdg1[i]->Clone(dkdg1name+"new"));
    P_dkdg1[i]->SetDirectory(0);
  }
}

RooATGCSemiAnalyticPdf::~RooATGCSemiAnalyticPdf() {
  for(int i = 0; i<7; ++i) {
    if (P_dk[i])
      delete P_dk[i];
    if (P_dg1[i])
      delete P_dg1[i];
    if (P_dkdg1[i])
      delete P_dkdg1[i];
  }
  delete[] P_dk;
  delete[] P_dg1;
  delete[] P_dkdg1;
}

Double_t RooATGCSemiAnalyticPdf::evaluate() const 
{ 
  // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 

  TProfile2D ** P = NULL;
  double v1(0.0), v2(0.0);
  switch(type_) {
  case dkglZ:
    P = P_dk;
    v1 = lZ;
    v2 = dkg;
    break;
  case dg1lZ:
    P = P_dg1;
    v1 = lZ;
    v2 = dg1;
    break;
  case dkdg1:
    P = P_dkdg1;
    v1 = dkg;
    v2 = dg1;
    break;
  case notype:
    assert(NULL && "invalid limit type!");
    break;
  }
  
  if (not P[0]) {
    TFile f(profileFilename);
    readProfiles(f);
    f.Close();
  }

  if (v1 < P[0]->GetXaxis()->GetXmin())
    v1 = P[0]->GetXaxis()->GetXmin();
  if (v1 > P[0]->GetXaxis()->GetXmax())
    v1 = P[0]->GetXaxis()->GetXmax();
  if (v2 < P[0]->GetYaxis()->GetXmin())
    v2 = P[0]->GetYaxis()->GetXmin();
  if (v2 > P[0]->GetYaxis()->GetXmax())
    v2 = P[0]->GetYaxis()->GetXmax();
 
  double ret(0.);
  for(int i = 0; i<= 6; i++) {
    // std::cout << P_dk[i]->GetName() << '\n';
    ret += P[i]->Interpolate(v1, v2)*TMath::Power(x, i)*SM_shape;
  }

  if (ret < 0.) ret = 0.;
  return ret; 
}

Int_t RooATGCSemiAnalyticPdf::
getAnalyticalIntegral(RooArgSet& allVars,RooArgSet& analVars, 
		      const char* /*rangeName*/) const {  
  if (matchArgs(allVars,analVars,x)) return 1 ;
  return 0 ;
}

Double_t RooATGCSemiAnalyticPdf::
analyticalIntegral(Int_t code, const char* rangeName) const {  

  assert(code==1 && "invalid analytic integration code!");

  std::string rName = ( rangeName == 0 ? std::string("") : std::string(rangeName) );
  if( integral_basis.find(rName) == integral_basis.end() ) {
    initializeNormalization(rName,x.arg(),SM_shape.arg());
  }

  TProfile2D ** P = NULL;
  double v1(0.0), v2(0.0);
  switch(type_) {
  case dkglZ:
    P = P_dk;
    v1 = lZ;
    v2 = dkg;
    break;
  case dg1lZ:
    P = P_dg1;
    v1 = lZ;
    v2 = dg1;
    break;
  case dkdg1:
    P = P_dkdg1;
    v1 = dkg;
    v2 = dg1;
    break;
  default:
    assert(code==1 && "invalid limit type!");
    break;
  }

  if (not P[0]) {
    TFile f(profileFilename);
    readProfiles(f);
    f.Close();
  }

  if (v1 < P[0]->GetXaxis()->GetXmin())
    v1 = P[0]->GetXaxis()->GetXmin();
  if (v1 > P[0]->GetXaxis()->GetXmax())
    v1 = P[0]->GetXaxis()->GetXmax();
  if (v2 < P[0]->GetYaxis()->GetXmin())
    v2 = P[0]->GetYaxis()->GetXmin();
  if (v2 > P[0]->GetYaxis()->GetXmax())
    v2 = P[0]->GetYaxis()->GetXmax();

  double ret(0.);
  for(int i = 0; i<= 6; ++i) {
    ret += P[i]->Interpolate(v1,v2)*integral_basis[rName][i];
  }
  return ret;
}
