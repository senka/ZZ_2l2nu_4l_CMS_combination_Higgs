/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "HiggsAnalysis/CombinedLimit/interface/RooATGCProcessScaling_wz.h" 

#include <math.h> 
#include "TMath.h" 
#include "RooFormulaVar.h"
#include "RooRealVar.h"
#include "RooFit.h"

#include "TFile.h"

ClassImpUnique(RooATGCProcessScaling_wz,MAGICWORDOFSOMESORT_WZ) 

RooATGCProcessScaling_wz::RooATGCProcessScaling_wz() : 
  type_(notype), P_dk(0), P_dg1(0), P_dkdg1(0)
{
  initializeProfiles();
}

RooATGCProcessScaling_wz::RooATGCProcessScaling_wz(const char *name, 
					     const char *title,
					     RooAbsReal& _x,
					     RooAbsReal& _dkg,
					     RooAbsReal& _lZ,
					     RooAbsReal& _dg1,
					     RooAbsReal& _SM_shape,
					     const char * parFilename) :
   RooAbsReal(name,title),
   // here
   //  x("x","x",this,_x),
   //   x(_x),
   lZ("lZ","lZ",this,_lZ),
   dkg("dkg","dkg",this,_dkg),
   dg1("dg1","dg1",this,_dg1),
   type_(notype),
   profileFilename(parFilename),
   P_dk(0), P_dg1(0), P_dkdg1(0)
{ 
  initializeProfiles();
  initializeNormalization(_x,_SM_shape);
  const char* pwd = gDirectory->GetPath();
  TFile *f = TFile::Open(parFilename,"READ");  
  gDirectory->cd(pwd);
  //  readProfiles(*f);
  std::vector<double> bins_;

  const RooRealVar& rdep = dynamic_cast<const RooRealVar&>(_x);
  int N_bins=rdep.getBinning("").numBins();
    cout << " RooATGCProc place 7 N_bins "<< N_bins << endl;

  for (int i=0;i<N_bins;i++){
    if (i==0) bins_.push_back(rdep.getBinning("").binLow(i));
    bins_.push_back(rdep.getBinning("").binHigh(i));
  }

  readProfiles(bins_,*f);
  f->Close();
} 

RooATGCProcessScaling_wz::
RooATGCProcessScaling_wz(const RooATGCProcessScaling_wz& other, 
		      const char* name) :  
  RooAbsReal(other,name),
  // here
  //  x(other.x),
  //  x("x",this,other.x),
  lZ("lZ",this,other.lZ),
  dkg("dkg",this,other.dkg),
  dg1("dg1",this,other.dg1),
  type_(other.type_),
  SM_integral(other.SM_integral),
  integral_basis(other.integral_basis),
  bins(other.bins),
  profileFilename(other.profileFilename),
  P_dk(0), P_dg1(0), P_dkdg1(0)
{ 
  initializeProfiles();
  const char* pwd = gDirectory->GetPath();
  TFile *f = TFile::Open(profileFilename,"READ");  
  gDirectory->cd(pwd);  
  //  readProfiles(x,*f);
  readProfiles(bins,*f);
  //  readProfiles(rdep,*f);
  f->Close();
} 

void RooATGCProcessScaling_wz::initializeProfiles() {
  int const N_bins=20;
    cout << " RooATGCProc place 8 N_bins "<< N_bins << endl;

  P_dk = new TH2D*[N_bins]();
  P_dg1 = new TH2D*[N_bins]();
  P_dkdg1 = new TH2D*[N_bins]();
}

void RooATGCProcessScaling_wz::initializeNormalization(const RooAbsReal& dep,
						    const RooAbsReal& shape) {
  /*
  const RooRealVar& rdep = dynamic_cast<const RooRealVar&>(dep);
  rdep.setRange("integralRange", min, max);
  */

  ///////////////////////
  //*****
  const RooRealVar& rdep = dynamic_cast<const RooRealVar&>(dep);
  RooRealVar& b = const_cast<RooRealVar&>(rdep);
  
  //  const RooRealVar& rdep = dynamic_cast<const RooRealVar&>(dep);
  bool bin_true=rdep.hasBinning("");
  if (!bin_true)
    cout <<"\t @@@@@@@@@@@ can't find biining! (RooATGCProcessScaling file)" << endl;

  int N_bins=rdep.getBinning("").numBins();

  cout << " RooATGCProc place 1 N_bins "<< N_bins << endl;
  //  RooAbsBinning& getBinning(const char* name = 0, Bool_t verbose = kTRUE, Bool_t createOnTheFly = kFALSE)
  ///////////////////////

  /*
  int const N_bins=15;
  int const bins_first=200.;
  int const bins_last=800.;
  double bin_width=(bins_last-bins_first)/N_bins;
  */

  
  RooAbsReal* integral = shape.createIntegral(RooArgSet(dep),RooArgSet());
  SM_integral = integral->getVal();
  delete integral;
  
  cout << " RooATGCProc place 2 N_bins "<< N_bins << endl;

  //  double SM_integral;

  for(int i=0; i<N_bins; ++i) {
    cout <<"bins in ProcessScaling" << endl;
    /*
    Double_t bin_low=bins_first+(i*bin_width);
    Double_t bin_high=bins_first+(i+1)*bin_width;
    */
    int bin_low=rdep.getBinning("").binLow(i);
    int bin_high=rdep.getBinning("").binHigh(i);

    /* // moved to *****
    const RooRealVar& rdep = dynamic_cast<const RooRealVar&>(dep);
    RooRealVar& b = const_cast<RooRealVar&>(rdep);
    */
    const string intRange="integRange";
    b.setRange((const char*)intRange.c_str(),bin_low,bin_high); //ok
    RooAbsReal* integral = shape.createIntegral(RooArgSet(rdep),RooArgSet(),(const char*)intRange.c_str());
    cout <<"processscaling bin "<< bin_low<<"-"<<bin_high<<"  integral: "<<integral->getVal()  << endl;
    //    integral_basis.push_back(integral->getVal()/(bin_high-bin_low));
    integral_basis.push_back(integral->getVal());
    if (i==0){
      bins.push_back(bin_low);
      cout << " \t\t first bin: filling bin in vector "<<bin_low <<endl;
    }
    bins.push_back(bin_high);
    cout << " \t\t first bin: filling bin in vector "<<bin_high <<endl;

    delete integral;
    /*
    RooAbsReal* integral_SM = shape.createIntegral(RooArgSet(dep),RooArgSet(),(const char*)intRange.c_str());
    SM_integral += integral_SM->getVal()/(bin_high-bin_low));
    delete integral_SM;
    */

  }

  /*
  for( int i = 0; i<=15; ++i ) {
    RooFormulaVar temp("temp","integral of x^i * shape",
    		       Form("@0"),RooArgList(shape));
    integral = temp.createIntegral(RooArgSet(dep),RooArgSet()
				   //,"signal"
				   );

    integral_basis.push_back(integral->getVal());
    delete integral;
  }
  */

}

//void RooATGCProcessScaling_wz::readProfiles(const RooAbsReal& dep,TDirectory& dir) const {
void RooATGCProcessScaling_wz::readProfiles(std::vector<double> bins,TDirectory& dir) const {
  /*
int const N_bins=15;
int const bins_first=200.;
int const bins_last=800.;
  */

  //here:
  /*
  const RooRealVar& rdep = dynamic_cast<const RooRealVar&>(dep);
  int N_bins=rdep.getBinning("").numBins();
  */

  int N_bins=bins.size()-1;

  cout << " RooATGCProc place 3 N_bins "<< N_bins << endl;
  //  double bin_width=(bins_last-bins_first)/N_bins;

  int i;
  for(i=0; i<N_bins; ++i) {

    /*
    //here    
    int bin_low=rdep.getBinning("").binLow(i+1);
    int bin_high=rdep.getBinning("").binHigh(i+1);
    */

    //    int bin_low=bins[i];
    //    int bin_high=bins[i+1];

    if (P_dk[i]) delete P_dk[i];
    //    TString dkname = TString::Format("p%i_lambda_dkg", i);
    //    TString dkname = TString::Format("bin_content_lam_dk_%i_%ito%iGeV",i+1,bin_low,bin_high);
    TString dkname = TString::Format("bin_content_lam_dk_%i",i+1);
    P_dk[i] = dynamic_cast<TH2D *>(dir.Get(dkname)->Clone(dkname+"new"));
    P_dk[i]->SetDirectory(0);
    if (P_dg1[i]) delete P_dg1[i];
    //    TString dg1name = TString::Format("p%i_lambda_dg1", i);
    //    TString dg1name = TString::Format("bin_content_lam_dg_%i_%ito%iGeV",i+1,bin_low,bin_high);
    TString dg1name = TString::Format("bin_content_lam_dg_%i",i+1);
    P_dg1[i] = dynamic_cast<TH2D *>(dir.Get(dg1name)->Clone(dg1name+"new"));
    P_dg1[i]->SetDirectory(0);
    //    TString dkdg1name = TString::Format("p%i_dkg_dg1", i);
    //    TString dkdg1name = TString::Format("bin_content_dk_dg_%i_%ito%iGeV",i+1,bin_low,bin_high);
    TString dkdg1name = TString::Format("bin_content_dk_dg_%i",i+1);
    P_dkdg1[i] = dynamic_cast<TH2D *>(dir.Get(dkdg1name)->Clone(dkdg1name+"new"));
    P_dkdg1[i]->SetDirectory(0);
  }

  // for (i=0; i<=6; i++) {
  //   std::cout << 'P' << i << "_dk " << P_dk[i]->GetName() << '\n';
  // }
}

void RooATGCProcessScaling_wz::readProfiles(RooATGCProcessScaling_wz const& other) {

  int N_bins=other.bins.size()-1;
  cout << " RooATGCProc place 4 N_bins "<< N_bins << endl;
  //  int N_bins=rdep.getBinning("").numBins();


  for (int i = 0; i<N_bins; ++i) {    
    /*
    int bin_low=rdep.getBinning("").binLow(i+1);
    int bin_high=rdep.getBinning("").binHigh(i+1);
    */
    //    int bin_low=bins[i];
    //    int bin_high=bins[i+1];
    //    TString dkname = TString::Format("p%i_lambda_dkg", i);
    //    TString dkname = TString::Format("bin_content_lam_dk_%i_%ito%iGeV",i+1,bin_low,bin_high);
    TString dkname = TString::Format("bin_content_lam_dk_%i",i+1);
    P_dk[i] = dynamic_cast<TH2D *>(other.P_dk[i]->Clone(dkname+"new"));
    P_dk[i]->SetDirectory(0);
    //    TString dg1name = TString::Format("p%i_lambda_dg1", i);
    //    TString dg1name = TString::Format("p%i_lambda_dg1", i);
    //    TString dg1name = TString::Format("bin_content_lam_dg_%i_%ito%iGeV",i+1,bin_low,bin_high);
    TString dg1name = TString::Format("bin_content_lam_dg_%i",i+1);
    P_dg1[i] = dynamic_cast<TH2D *>(other.P_dg1[i]->Clone(dg1name+"new"));
    P_dg1[i]->SetDirectory(0);
    //    TString dkdg1name = TString::Format("p%i_dkg_dg1", i);
    //    TString dkdg1name = TString::Format("bin_content_dk_dg_%i_%ito%iGeV",i+1,bin_low,bin_high);
    TString dkdg1name = TString::Format("bin_content_dk_dg_%i",i+1);
    P_dkdg1[i] = dynamic_cast<TH2D *>(other.P_dkdg1[i]->Clone(dkdg1name+"new"));
    P_dkdg1[i]->SetDirectory(0);
  }
}

RooATGCProcessScaling_wz::~RooATGCProcessScaling_wz() {
  //  int N_bins=rdep.getBinning("").numBins();
  int N_bins=20;
  cout << " RooATGCProc place 6 N_bins "<< N_bins << endl;

  for(int i = 0; i<N_bins; ++i) {
    if (P_dk[i])
      delete P_dk[i];
    if (P_dg1[i])
      delete P_dg1[i];
    if (P_dkdg1[i])
      delete P_dkdg1[i];
  }
  delete[] P_dk;
  delete[] P_dg1;
  delete[] P_dkdg1;
}

Double_t RooATGCProcessScaling_wz::evaluate() const 
{ 
  std::cout << "@@@@@@@@ doing RooATGCProcessScaling_wz::evaluate()" << std::endl;
  
  TH2D ** P = NULL;
  double v1(0.0), v2(0.0);
  switch(type_) {
  case dkglZ:
    P = P_dk;
    v1 = lZ;
    v2 = dkg;
    break;
  case dg1lZ:
    P = P_dg1;
    v1 = lZ;
    v2 = dg1;
    break;
  case dkdg1:
    P = P_dkdg1;
    v1 = dkg;
    v2 = dg1;
    break;
  default:
    assert(NULL && "invalid limit type!");
    break;
  }
  std::cout << "@@@@@@@@   ... found type" << std::endl;

  if (not P[0]) {
    TFile f(profileFilename);
  std::cout << "@@@@@@@@   ... read profiles" << std::endl;
  readProfiles(bins,f);
  std::cout << "@@@@@@@@   ...   read" << std::endl;
    f.Close();
  }

  std::cout << "@@@@@@@@   ... get max/min" << std::endl;

  if (v1 < P[0]->GetXaxis()->GetXmin())
    v1 = P[0]->GetXaxis()->GetXmin();
  if (v1 > P[0]->GetXaxis()->GetXmax())
    v1 = P[0]->GetXaxis()->GetXmax();
  if (v2 < P[0]->GetYaxis()->GetXmin())
    v2 = P[0]->GetYaxis()->GetXmin();
  if (v2 > P[0]->GetYaxis()->GetXmax())
    v2 = P[0]->GetYaxis()->GetXmax();
  std::cout << "@@@@@@@@   ...   got max/min" << std::endl;

  double ret(0.);
  /*
  for(int i = 0; i<= 6; i++) {
    ret += P[i]->Interpolate(v1,v2)*integral_basis[i];
  }
*/



  ///////////////////////////////////////
  int N_bins=bins.size()-1;
  cout <<" place 80 N_bins "<<N_bins << endl;
  //  for(int i = 0; i< 15; i++) {
  for(int i = 0; i<N_bins; i++) {
    //    ret += P[i]->Interpolate(v1,v2)*integral_basis[i]*(bins[i+1]-bins[i]);
    ret += P[i]->Interpolate(v1,v2)*integral_basis[i];
  }
  cout << "ret/SM_integral= "<< ret<<"/"<<SM_integral<<" = "<< ret/SM_integral << endl;
  return ret/SM_integral;

}

